package ru.skypro;

import java.time.LocalDate;
import java.time.Year;
import java.util.Arrays;

public class MyFunction {

    public static void main(String[] args) {
        printIsLeapYear(2020);
        printVersion(1, 2015);
        System.out.println("Дней для доставки " + calculateDeliveryDays(90));
        validateString("abc");
        validateString("abbcc");

        int[] arr = {5, 4, 3, 2, 1};
        System.out.println(Arrays.toString(arr));
        revertArray(arr);
        System.out.println(Arrays.toString(arr));

    }

// задача 1
//Реализуйте метод, который получает в качестве параметра год, а затем проверяет, является ли он високосным,
// и выводит результат в консоль.  Эту проверку вы уже реализовывали в задании по условным операторам.
//Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
//Результат программы выведите в консоль. Если год високосный, то должно быть выведено
// “*номер года —* високосный год”. Если год не високосный, то, соответственно: “*номер года —* не **високосный год”.
    public static void printIsLeapYear(int year) {
        boolean leapYear =  ((year % 4) == 0) && ((year % 100) != 0 || (year % 400) == 0);
        if (leapYear) {
            System.out.println(year + " високосный год");
        } else {
            System.out.println(year + " не високосный год");
        }

    }

    // задача 2
//Вспомним задание 2 по условным операторам, где нам необходимо было предложить пользователю облегченную версию приложения.
//Текст прошлого задания
//К нам пришли коллеги и сообщили, что нам нужно знать не только операционную систему телефона, но и год его создания: от этого зависит, подойдет ли приложение для телефона или оно просто не установится.
//Если телефон произведен с 2015 по нынешний год, то приложение будет работать корректно.
//Если телефон произведен ранее 2015 года, то клиенту нужно посоветовать установить облегченную версию приложения.
//Ваша задача: написать программу, которая выдает соответствующее сообщение клиенту при наличии двух условий — операционной системы телефона (iOS или Android) и года производства.
//Если год выпуска ранее 2015 года, то к сообщению об установке нужно добавить информацию об облегченной версии.
//Например, для iOS оно будет звучать так:
//«Установите облегченную версию приложения для iOS по ссылке».
//А для Android так:
//«Установите облегченную версию приложения для Android по ссылке».
//При этом для пользователей с телефоном с 2015 года выпуска нужно вывести обычное предложение об установке приложения.
//Для обозначения года создания используйте переменную clientDeviceYear, где необходимо указать 2015 год.
//**Важно**: вложенность больше двух этажей не допускается (условный оператор внутри условного оператора).
//Напишите метод, куда подаются два параметра: тип операционной системы (ОС) ( 0 — iOS или 1 — Android ) и год выпуска устройства.
//Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
//Текущий год можно получить таким способом:
//```java
//int currentYear = LocalDate.now().getYear();
//```
//Или самим задать значение вручную, введя в переменную числовое значение.
//В результате программа должна выводить в консоль в зависимости от исходных данных, какую версию приложения (обычную или lite) и для какой ОС (Android или iOS) нужно установить пользователю.
    public static void printVersion(int clientOS, int deviceYear) {
        int currentYear = LocalDate.now().getYear(); //2022
        if (clientOS == 0 && deviceYear < currentYear)
            System.out.println("Установите облегченную версия для iOS");
        else if (clientOS == 0 && deviceYear >= currentYear)
            System.out.println("Установите версию для iOS");
        else if (clientOS == 1 && deviceYear < currentYear)
            System.out.println("Установите облегченную версия для Android");
        else
            System.out.println("Установите версия для Android");

    }

    // задача 3
//Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
//Наша задача — доработать код, а именно написать метод, который на вход принимает дистанцию и возвращает итоговое количество дней доставки.
    public static int calculateDeliveryDays(int deliveryDistance) {
        int deliveryDays = 1;
        if (deliveryDistance > 20) {
            deliveryDays++;
        }
        if (deliveryDistance > 60) {
            deliveryDays++;
        }
        if (deliveryDistance > 80) {
            deliveryDays++;
        }

        return deliveryDays;
    }

    //задача 4
//Вернемся к задаче о валидаторе текста из урока по строкам.
//Условие задачи из урока 1.7
//### Повышенная сложность. Задание 8
//Дана строка из букв английского алфавита  "".
//Нужно найти и напечатать буквы, которые дублируются в строке.
//Обратите внимание, что строка отсортирована, т. е. дубли идут друг за другом.
//В итоге в консоль должен быть выведен результат программы: "acdgijk".
    public static void validateString(String str) {

        int flag = 0;
        String symbol = "";
        for (int i = 0; i < str.length() - 1; i++)
            if (str.charAt(i) == str.charAt(i + 1)) {
                symbol += str.charAt(i);
                flag =1;
            }

        if(flag == 1){
            System.out.println("Дубликат найден: " + symbol);
        }
        else
            System.out.println("Дубликатов не найдено");

    }

    // задача 5
//Напишите метод, который получает на вход массив и переставляет все его элементы в обратном порядке.
//Подобное задание вы решали в домашнем задании по массивам.
//Текст прошлого задания
//Отойдем от подсчетов.
//В нашей бухгалтерской книге появился баг. Что-то пошло нет так, и Ф. И. О. сотрудников начали отображаться в обратную сторону. Т. е. вместо «Иванов Иван Иванович» мы имеем «чивонавИ навИ вонавИ».
//Данные с именами сотрудников хранятся в виде массива символов (char[]).
//Напишите код, который в случае такого бага будет выводить Ф. И. О. сотрудников в корректном виде. В качестве данных для массива используйте:
//char[] reverseFullName = { 'n', 'a', 'v', 'I', ' ', 'v', 'o', 'n', 'a', 'v', 'I'};
//В результате в консоль должно быть выведено "Ivanov Ivan".
//*Важно**: не используйте дополнительные массивы для решения этой задачи. Необходимо корректно пройти по массиву циклом и распечатать его элементы в правильном порядке.
//В метод приходит массив, допустим:
//{3, 2, 1, 6, 5}.
//Нужно без вспомогательного массива переместить элементы так, чтобы поданный массив стал: {5, 6, 1, 2, 3}.
//Рекомендуем написать этот метод без возвращаемого значения. Вы будете приятно удивлены, что даже если мы не вернем массив, первоначальный массив изменится, когда мы будем модернизировать пришедший в виде параметра массив внутри метода.
//Причину такого поведения ссылочных типов (объектов) вы узнаете на следующем уроке или на QA-вебинаре.
    public static void revertArray(int[] arr) {

        for (int i = 0; i < arr.length; i++) {
            arr[i] = arr[arr.length - 1 - i];
        }

    }

}